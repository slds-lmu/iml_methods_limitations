---
output:
  html_document: default
  pdf_document: default
---
# Comparison of ALE and PDP

*Author: Jakob Bodensteiner*

<!-- TODO:  referencen auf Apley usw noch setzen  [@Apley2016, page 11], [@molnar2019]-->
<!-- TODO:  analyze oder analyse ? -->


This subchapter of ALE will focus on the comparison of ALE and PDP, especially on the influence of correlation in the underlying datasets. At first the interpretation for the regular one dimensional (or 1D) ALE to the 1D PDP will be discussed. Thereafter two dimensional ALEs will be introduced and their difference to PDPs will be explained. Thereafter a runtime comparison will be discussed. To conclude this chapter a real world example will be analyzed with ALE, PDP and ICE. 

## Comparison one feature

So far in this book one could already see a few examples of the PDP for one feature and its limitations. The ALE is kind of the solution for the biggest issue with the PDP. The ALE can interpret models predicting on correlated variables correctly, while the PDP may fail in this case. Before the two methods will be compared, here comes a short reminder regarding the interpretation. 
Given a value for the feature of interest ...

...the 1D PDP measures the expected prediction for this value by averaging over the prediction of all observations pretending the feature of interest is that value.

... the 1D ALE shows the expected and centered first order effect of this feature.

With this interpretations in mind the first example with artifical data will be discussed.

### Example 1: Multiplicative prediction function

The following Problem is constructed: There is a data set consisting of 150 observations with three features ($x_1$, $x_2$, $x_3$) and the target variable $y = x_1  x_2  x_3$.
The features of each observation are sampled from these disrtibutions.
$X_1 \sim \mathcal{U}(0,~0.5)$, $X_2 \sim \mathcal{N}(2,~2)$ and $X_3\mid X_2, X_1 \sim \mathcal{N}(X_2,X_1)$
So features one and two are independent from each other, while $x_3$ is strongly correlated with $x_2$ and not independent from $x_1$, although there is no influence of $x_1$ on the expected value of $x_3$. In this example (and in all other examples with artificial data in this chapter) the prediction function is not fitted but set as the target variable  $f(x_1, x_2, x_3) = y = x_1 x_2 x_3$. By setting the prediction function instead of fitting a learner on the data it is ensured that one can imagine how the 'real' influence of each feature is. This way one can see clearly if ALE or PDP are making mistakes in the interpretation. If one would fit a random forest one could never be sure if the ALE and PDP plots are making a mistake in explaining the fitted forest or if the mistake is made by the learner and the explanation of the learner itself would actually be fine. This will become clear at the end of the chapter when the real world example will be discussed.

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, ew, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, ew, sd)
  x3 <- rnorm(n, x2, x1)
  y <- x1 * x2 * x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

n <- 150
mi <- "0"
ma <- "0p5"
ew <- "5"
va <- "1"
# create example df
cor_df <- get_cor_df(n, 0, 0.5, 5, 1)

# fit splines on df just to make predictor run
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 * x2 * x3: #################
prediction_function_123 <- function(x1, x2, x3) {
  return(x1 * x2 * x3)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
  a <- numeric(0)
  for (i in 1:nrow(newdata)){
    a[i]<- prediction_function_123(newdata[i, 1], newdata[i, 2], newdata[i, 3])
  }
  return(a)
})


# plot ale x1 
ale_x1 <- FeatureEffect$new(predictor, feature = 'x1')
p_ale_x1 <- plot(ale_x1) + theme_bw()
# plot pdp on same situation x1
pdp_x1 = FeatureEffect$new(predictor, feature = 'x1', method = 'pdp')
p_pdp_x1 <- plot(pdp_x1) + theme_bw()

# plot_grid(plot(ale) + theme_bw(), pdp$plot()) + ggtitle("peter")

# plot ale x2
ale_x2 <- FeatureEffect$new(predictor, feature = 'x2')
p_ale_x2 <- plot(ale_x2) + theme_bw()
# plot pdp on same situation x2
pdp_x2 = FeatureEffect$new(predictor, feature = 'x2', method = 'pdp')
p_pdp_x2 <- plot(pdp_x2) + theme_bw()

# plot ale x3
ale_x3 <- FeatureEffect$new(predictor, feature = 'x3')
p_ale_x3 <- plot(ale_x3) + theme_bw()
# plot pdp on same situation x3
pdp_x3 = FeatureEffect$new(predictor, feature = 'x3', method = 'pdp')
p_pdp_x3 <- plot(pdp_x3) + theme_bw()

form <- "x1x2x3"
# make a nice plot:
title_text <- paste("ALEs for each feature", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(p_ale_x1, p_ale_x2, p_ale_x3, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "ALEs"
save_text <- paste(paste(meth, form, n, mi, ma, ew, va, sep = "_"), ".png", sep = "")
ggsave(save_text,
       plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
       width = 14, height = 7, units = "cm")

title_text <- paste("PDPs for each feature", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(p_pdp_x1, p_pdp_x2, p_pdp_x3, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "PDPs"
# save_text <- paste(paste(meth, form, n, mi, ma, ew, va, sep = "_"), ".png", sep = "")
# ggsave(save_text,
#        plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
#        width = 14, height = 7, units = "cm")

```

```{r pdpsx1x2x3, fig.cap='(ref:pdpsx1x2x3Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_PDPs_x1x2x3_150_0_0p5_2_2.png")
```
(ref:pdpsx1x2x3Cap) PDPs for prediction function $f(x_1, x_2, x_3) = x_1 x_2 x_3$.

```{r alesx1x2x3, fig.cap='(ref:alesx1x2x3Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_ALEs_x1x2x3_150_0_0p5_2_2.png")
```
(ref:alesx1x2x3Cap) ALEs for prediction function $f(x_1, x_2, x_3) = x_1 x_2 x_3$.

Plot \@ref(fig:pdpsx1x2x3) shows the 1D PDP for each of the three features. One can clearly see that the PDP detects a linear influence on the prediction for all 3 of the features.
On the other hand the ALE (figure \@ref(fig:alesx1x2x3)) attests the linear influence to the feature $x_1$ only. This plot exposes a weakness of the ALE compared to the PDP. The ALE depends much more on the sampled data than the PDP does. The result is that the ALE can look a bit shaky. In this special case it is that seriously one almost can't see the linear influence. If there would be more data or less intervals for the estimation, the plot would look more like the PDP for feature $x_1$. The two other features seem to rather have an exponential influence on the prediction. And this is the case indeed, since it is the 'true' link between prediction and the correlated features. Feature $x_3$ has (in expectation) the same value as $x_2$. Especially if feature $x_1$ has small values the variance of feature $x_2$ around $x_3$ becomes small as well. As consequence the last part of the prediction function $x_2 \times x_3$ can be approximated by $x_2^2$ or $x_3^2$. This explains the exponential influence. By changing the prediction formula to $f(x_1, x_2, x_3) = y = x_1 \times x_2^2$ the following PDP and ALE plots are estimated.

```{r pdpsx1x22, fig.cap='(ref:pdpsx1x22Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_PDPs_x1x22_150_0_0p5_2_2.png")
```
(ref:pdpsx1x22Cap) PDPs for prediction function $f(x_1, x_2, x_3) = x_1 \times x_2^2$.

```{r alesx1x22, fig.cap='(ref:alesx1x22Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_ALEs_x1x22_150_0_0p5_2_2.png")
```
(ref:alesx1x22Cap) ALEs for prediction function $f(x_1, x_2, x_3) = x_1 \times x_2^2$.

Plots \@ref(fig:pdpsx1x22) and \@ref(fig:alesx1x22) clearly show the linear influence of $x_1$ again. Additionally this time both (ALE and PDP) attest an exponential influence to feature $x_2$ on the prediction. Since $x_3$ does not have any influence on the prediction function, it is correct, that there is no influence detected.
The reason for this is the calculation method for the PDP. With the new prediction formula only depending on uncorrelated features $x_1$ and $x_2$, the PDP works well. Since now the approach of PDP to calculate the mean effect is correct.

### Example 2: Additive prediction function
In this example PDP and ALE will be applied to an additive prediction function.

Again a data set consisting of three features ($x_1$, $x_2$, $x_3$) is constructed. In this case the target variable is $y = x_1 + x_2 - x_3$. The prediction function is not learned but set to exactly the target variable, meaning $f(x_1, x_2, x_3) = x_1 + x_2 - x_3$.
The distributions are similar to the ones from example 1 and again 150 observations are sampled.
$X_1 \sim \mathcal{U}(0,~2)$, $X_2 \sim \mathcal{N}(2,~0.5)$ and $X_3\mid X_2 \sim \mathcal{N}(X_2,~0.5)$

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, 2, sd)
  x3 <- rnorm(n, x2, sd)
  y <- x1 + x2 - x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

n <- 150
mi <- "0"
ma <- "2"
va <- "0p5"
# create example df
cor_df <- get_cor_df(n, 0, 2, 0.5)


# fit splines on df
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 + x2 - x3: #################
prediction_function_1plus2minus3 <- function(x1, x2, x3) {
  return(x1 + x2 - x3)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
                            a <- numeric(0)
                            for (i in 1:nrow(newdata)){
                              a[i]<- prediction_function_1plus2minus3(newdata[i, 1], newdata[i, 2], newdata[i, 3])
                            }
                            return(a)
                          })

################### 1D all linear ###############################################

# plot ale x1 
ale_x1 <- FeatureEffect$new(predictor, feature = 'x1')
p_ale_x1 <- plot(ale_x1) + theme_bw()
# plot pdp on same situation x1
pdp_x1 = FeatureEffect$new(predictor, feature = 'x1', method = 'pdp')
p_pdp_x1 <- plot(pdp_x1) + theme_bw()
#ggplotly(p_ale_x1)
# plot_grid(plot(ale) + theme_bw(), pdp$plot()) + ggtitle("peter")

# plot ale x2
ale_x2 <- FeatureEffect$new(predictor, feature = 'x2')
p_ale_x2 <- plot(ale_x2) + theme_bw()
# plot pdp on same situation x2
pdp_x2 = FeatureEffect$new(predictor, feature = 'x2', method = 'pdp')
p_pdp_x2 <- plot(pdp_x2) + theme_bw()

# plot ale x3
ale_x3 <- FeatureEffect$new(predictor, feature = 'x3')
p_ale_x3 <- plot(ale_x3) + theme_bw()
# plot pdp on same situation x3
pdp_x3 = FeatureEffect$new(predictor, feature = 'x3', method = 'pdp')
p_pdp_x3 <- plot(pdp_x3) + theme_bw()


form <- "x1_plus_x2_minus_x3"
# make a nice plot:
title_text <- paste("ALEs for each feature", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(p_ale_x1, p_ale_x2, p_ale_x3, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "ALEs"
save_text <- paste(paste(meth, form, n, mi, ma, va, sep = "_"), ".png", sep = "")
ggsave(save_text,
       plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
       width = 14, height = 7, units = "cm")


title_text <- paste("PDPs for each feature", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(p_pdp_x1, p_pdp_x2, p_pdp_x3, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "PDPs"
save_text <- paste(paste(meth, form, n, mi, ma, va, sep = "_"), ".png", sep = "")
ggsave(save_text,
       plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
       width = 14, height = 7, units = "cm")
```

```{r pdpsx1px2mx3, fig.cap='(ref:pdpsx1px2mx3Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_PDPs_x1_plus_x2_minus_x3_150_0_2_0p5.png")
```
(ref:pdpsx1px2mx3Cap) PDPs for prediction function $f(x_1, x_2, x_3) = x_1 + x_2 - x_3$.

```{r alesx1px2mx3, fig.cap='(ref:alesx1px2mx3Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_ALEs_x1_plus_x2_minus_x3_150_0_2_0p5.png")
```
(ref:alesx1px2mx3Cap) ALEs for prediction function $f(x_1, x_2, x_3) = x_1 + x_2 - x_3$.

For this example one can see that the ALEs (\@ref(fig:alesx1px2mx3)) and PDPs (\@ref(fig:pdpsx1px2mx3)) are basically the same. Ignoring the centering both attest the same linear influence for all three features. And since it is an additive model this is actually correct. But neither the ALE nor the PDP recognise the strong correlation between the features $x_2$ and $x_3$. The real influence of features $x_2$ and $x_3$ is in expectation zero, since it is $x_2 - x_3$ and $E[X_3 \mid X_2] = X_2$. So $E[X_2 - X_3 \mid X_2] = 0$.
This shows a few points one has to be aware of when working with these plots.
In this example if one uses the interpretation of the PDP for feature x_2 and states 'If the value of feature $x_2$ is 2.5, then I expect the prediction to be 1.5' it would be wrong. The problem here is the extrapolation in the estimation of the PDP. So it does not take into account any connection between the features, but still works as good as the ALE in this example.
The general advantage of the ALE is the small chance of extrapolation in the estimation. But this does not mean it would recognise any correlation between the features in each scenario. And it is in general not possible to state something about the prediction with only one 1D ALE. The ALE is just showing the expected and centered main effect of the feature. In this example an interpretation like 'If feature $x_2$ has value 2.5 then in expectation the prediction will be 0.5 higher than the average prediction' is wrong. If one needs a statement like that the other strongly correlated features have to be taken into account as well. One has to be aware of higher order effects of the ALE, too.
To conclude the analysis of this example 2D ALEs are necessary. So it will be continued later this chapter.

## Comparison two features
Before the 2D ALE and PDP will be applied to the same predictors, the 2D ALE has to be derived. In the first place the theoretical formula will be defined. Thereafter the estimation will be explained and then the comparison to the 2D PDP will be made.

### The 2D ALE

#### Theoretical Formula 2D ALE

Similar to one variable of interest there is a theoretical formula for a 2-dimensional ALE. This ALE aims to visualize the 2nd order effect. Meaning one will just see the additional effect of interaction between those two features. The main effects of the features will not be shown in the 2D ALE. To explain the formula it will be assumed that $j$ and $l$ are the two features of interest. The rest of the features is represented by $c$. So in the following variable $x_c$ can be of higher dimension than 1. As for the 1D ALE there is again a theoretical derivative for the fittet function $\hat{f}$. But this time it is the derivative in the direction of both features of interest. So in the following this notation will hold:

$$ \hat{f}^{(j,~l)}(x_j,~x_l,~x_c) = \frac{\delta\hat{f}(x_j,~x_l,~x_c)}{\delta x_j~ \delta xl}$$

The whole formula would be very long, so it is split into 3 parts (compare [@Apley2016, page 8]):

1. The 2nd order effect ( TODO: set them formula xx)

2. 2nd order effect corrected for both main effects (formula xx)

3. The 2D ALE; the corrected 2D ALE centered for its mean overall effect (formula xx)

Following equation \@ref(eq:ale2DTheoretical1stLvl) is the 2nd order effect with no correction for main effects of $x_j$ and $x_l$. So this is not yet the pure 2nd order effect the 2D ALE is aiming for.

\begin{equation} 
\widetilde{\widetilde{ALE}}_{\hat{f},~j,~l}(x_j, x_l) = \int_{z_{0,~j}}^{x_j}  \int_{z_{0,~l}}^{x_l}             E[\hat{f}^{(j,~l)}(X_j,~X_l,~X_c)\mid X_j = z_j,~X_l = z_l]~dz_l~dz_j 
  (\#eq:ale2DTheoretical1stLvl)
\end{equation}

Now from the uncorrected 2nd order effect the two main effects of both features on the uncorrected 2D ALE are subtracted. In this way the main effects of $x_j$ and $x_l$ on the final ALE $ALE_{\hat{f},~j,~l}(x_j, x_l)$ are both zero [@Apley2016, page 9]. But be carefull, this is not centering by a constant as in the one dimensional ALE as can be seen in equation \@ref(eq:ale2DTheoreticalCorrection). This is a correction for the also accumulated main effects which of course vary in the directions of the features.

\begin{align} 
\begin{split}
\widetilde{ALE}_{\hat{f},~j,~l}(x_j, x_l) 
= &\widetilde{\widetilde{ALE}}_{\hat{f},~j,~l}(x_j, x_l) \notag \\ 
&-  \int_{z_{0,~j}}^{x_j}  E[\frac{\delta\widetilde{\widetilde{ALE}}_{\hat{f},~j,~l}(X_j, X_l)}{\delta X_j}\mid X_j = z_j]~dz_j \notag \\
&- \int_{z_{0,~l}}^{x_l}  E[\frac{\delta\widetilde{\widetilde{ALE}}_{\hat{f},~j,~l}(X_j, X_l)}{\delta X_l}\mid X_l = z_l]~dz_l
\end{split}
(\#eq:ale2DTheoreticalCorrection)
\end{align}

Equation \@ref(eq:ale2DTheoretical) shows the final (centered) 2D ALE. The subtraction in the formula is now the real centering to shift the 2nd order effect (corrected for the main effects) to zero with respect to the marginal distribution of $(X_j, ~ X_l)$.

\begin{equation} 
ALE_{\hat{f},~j,~l}(x_j, x_l) = \widetilde{ALE}_{\hat{f},~j,~l}(x_j, x_l) ~ -  E[\widetilde{ALE}_{\hat{f},~j,~l}(X_j, X_l)]
  (\#eq:ale2DTheoretical)
\end{equation}

In the appindex (ref TODO) one can find the calculation of the theoretical ALE for Example 1.


#### Estimation 2D ALE
Analogously to the 1D ALE in most cases it is not possible to calculate the 2D ALE. It has to be estimated. These estimation formulas are pretty long and might be confusing, especially the indices. But there will be a explenation including a visualization as well to clarify the estimation method.

First all variables have to be defined. The two features of interest are $x_j$ and $x_l$. The prediction function is $\hat{f}(x_j, x_l, x_{\setminus\{j,~l\}})$, while $x_{\setminus\{j,~l\}}$ represents all the rest of the features, so it can be of higher dimension than 1. 
The areas including data for feature $x_j$ and $x_l$ are divided into the same number of intervals, namely K. The intervals in $x_j$ direction are separated by $z_{k,j}$ for $k \in \{0,...,K\}$. $k_j(x_j)$ returns the intervalnumber in which $x_j$ lies. This holds for $z_{m,l}$ and $k_l(x_l)$ respectively in direction of $x_l$. $N_{\{j,~l\}}(k,m)$ is the crossproduct of the k-th and m-th interval (in $x_j$ and $x_l$ direction), so it is defined as $(z_{k-1,j}, z_{k,j}] \times z_{m-1,j}, z_{m,j}]$. $n_{\{j,~l\}}(k,m)$ is the number of those observations lying in this $N_{\{j,~l\}}(k,m)$ cell. The parameter i represents the i-th observation. With this variables in mind, the definition of the 2D ALE estimation can begin.

The estimation equvalent to Formula \@ref(eq:ale2DTheoretical1stLvl) is:

\begin{equation} 
\widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(x_j, ~x_l) = \sum_{k=1}^{k_j(x_j)} \sum_{m=1}^{k_l(x_l)}   \frac{1}{n_{\{j,~l\}}(k,m)}\sum_{i:~x_{\{j,~l\}}^{(i)}\in N_{\{j,~l\}}(k,m)} ~ \Delta_{\hat f}^{{\{j,~l\}}, ~k,~m} (x_{\setminus\{j,~l\}}^{(i)}),
  (\#eq:ale2DEst1stLvl)
\end{equation}

while the $\Delta$ function is:

\begin{align} 
\begin{split}
\Delta_{\hat f}^{{\{j,~l\}}, ~k,~m} (x_{\setminus\{j,~l\}}^{(i)}) = 
&[\hat f(z_{k,~j},~ z_{m,~l}, ~x_{\setminus\{j,~l\}}^{(i)}) - \hat f(z_{k-1,~j},~ z_{m,~l}, ~x_{\setminus\{j,~l\}}^{(i)})] \notag \\ 
&- [\hat f(z_{k,~j},~ z_{m-1,~l}, ~x_{\setminus\{j,~l\}}^{(i)}) - \hat f(z_{k-1,~j},~ z_{m-1,~l}, ~x_{\setminus\{j,~l\}}^{(i)})]
\end{split}
\end{align}
<!-- (\#eq:ale2DEstDelta) -->

Now the correction for the main effects (theoretical formula \@ref(eq:ale2DTheoreticalCorrection))is estimated:

\begin{align} 
\begin{split}
\widehat{\widetilde{ALE}}_{\hat{f},~j,~l}(x_j, ~x_l) = 
&\widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(x_j, ~x_l) \notag \\
&-  \sum_{k=1}^{k_j(x_j)} \frac{1}{n_j(k)} \sum_{m=1}^{K} ~ n_{\{j,~l\}}(k,m) [\widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(z_{k,~j}, ~z_{m,~l}) - \widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(z_{k-1,~j}, ~z_{m,~l})]\notag \\
&- \sum_{k=1}^{k_l(x_l)} \frac{1}{n_l(k)} \sum_{m=1}^{K} ~ n_{\{j,~l\}}(k,m) [\widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(z_{k,~j}, ~z_{m,~l}) - \widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(z_{k,~j}, ~z_{m-1,~l})]
\end{split}
  (\#eq:ale2DEstCorrection)
\end{align}

This is the uncentered 2D ALE since it is just corrected for its main effects. And this is not a real centering in the sense of subtracting a constant value. Now it will be centered for its estimation $E[\widehat{\widetilde{ALE}}_{\hat{f},~j,~l}(X_j, ~X_l)]$ and this is a constant, so there will be no effect on the general shape. Again this expected value has to be estimated, to complete the 2D ALE as is calculated in theoretical formula \@ref(eq:ale2DTheoreticalCorrection). 

\begin{equation}  
\widehat{ALE}_{\hat{f},~j,~l}(x_j, ~x_l) = 
\widehat{\widetilde{ALE}}_{\hat{f},~j,~l}(x_j, ~x_l) -
\sum_{k=1}^{K}\sum_{m=1}^{K} ~ n_{\{j,~l\}}(k,m) ~ \widehat{\widetilde{ALE}}_{\hat{f},~j,~l}(z_{k,~j}, ~z_{m,~l})
 (\#eq:ale2DEst)
\end{equation}

In difference to the ALE for one feature of interest, the 2D ALE is a two dimensional stepfunction, so there is no smoothing or something similar to make it a continuous function. 

This formulas are pretty long, so to get an intuition of the estimation figure \@ref(fig:ale2DEstimation) will be helpfull.

```{r ale2DEstimation, fig.cap='(ref:ale2DEstimationCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_ALE_2D_estimation.PNG")
```
(ref:ale2DEstimationCap) Visualisation of the absolut differences for the 2nd order effect [@Apley2016, page 13].

\@ref(eq:ale2DEstDelta)
To calculate the delta TODO refdelta for the uncorrected and uncentered ALE estimation in each cell the predictions for the data points in that cell will be calculated pretending the $x_l$ and $x_j$ values are cornervalues of the cell they are in. In the case of figure \@ref(fig:ale2DEstimation) these 2 dimensional cornervalues would be a,b,c,d. The delta for point x in this example would be calculated like this:

$$ \Delta_{\hat f}^{{\{j,~l\}}, ~4,~3} (x_{\setminus\{j,~l\}}) = [\hat f(b, ~x_{\setminus\{j,~l\}}) - \hat f(a, ~x_{\setminus\{j,~l\}})]~ - [\hat f(d, ~x_{\setminus\{j,~l\}}) - \hat f(c, ~x_{\setminus\{j,~l\}})]$$

The same would be done for point y and then the deltas would be averaged to get the mean delta for cell $N_{\{j,~l\}}(4,3)$. This would then be accumulated over all cells left or beneath this cell to get the uncorrected and uncentered ALE for the values in $N_{\{j,~l\}}(4,3)$. 

The correction for the main effects extracts the effect of the single features on the ALE so far and subtracts it from the raw formula (see \@ref(eq:ale2DEstCorrection)). To stick with this example the correction for the main effect of feature $x_j$ for values in $N_j(4)$ takes into account all cells in the first 4 columns and aggregates the first order effect. In cell $N_{\{j,~l\}}(4,3)$ this would look like this:

$$ \widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(b) - \widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(a)$$

The correction for $x_l$ looks pretty much the same just from the other direction. It takes into account the first 3 rows. So in cell $N_{\{j,~l\}}(4,3)$ the first order effect would be

$$ \widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(b) - \widehat{\widetilde{\widetilde{ALE}}}_{\hat{f},~j,~l}(d). $$

Thereafter the corrected ALE is centered for its mean (defined in equation \@ref(eq:ale2DEst)), pretty much the same way as is done for one dimension. But this time the aggregation is not just over a line but over a grid.

There are a few questions that might arise. First, how is the grid for the estimation defined? In the iml package the cells are the crossproducts of the intervals used for the 1D estimation. It would be very hard to make a grid of rectangles which all include roughly the same amount of data points. Another question could be: How does the estimation treat empty cells, including no datapoints? There are two options, they can either be ignored and greyed out or they recieve the value of their nearest neighbor rectangle, which is determined by the center of the cells. The last method is implemented in iml. This happens right after averaging over the $\Delta_{\hat f}^{{\{j,~l\}}, ~k,~m} (x_{\setminus\{j,~l\}})$s before the correction for the 1st order effects is done.


#### Example 1 continued - Theoretical and estimated 2D ALE

Before ALE and PDP will be compared for two features of interest, the analysis of example 1 will be continued in two dimensions, to get a first glance at the 2D ALE.

The data set is basically the same, just for sake of clearness in the 2D ALE example the distributions are a bit different.
We still consider a data set consisting of 150 observations with three features ($x_1$, $x_2$, $x_3$) and the prediction function $f(x_1, x_2, x_3) = x_1 x_2 x_3$.
But this time the three features are sampled from these disrtibutions.
$X_1 \sim \mathcal{U}(0,~0.5)$, $X_2 \sim \mathcal{N}(5,~1)$ and $X_3\mid X_2, X_1 \sim \mathcal{N}(X_2,X_1)$
So feature $x_2$ is expected to be 5 and has a lower variance than it has in example 1. The rest stays the same. 

With the formulas in the appindex (ref TODO) it is possible to calculate the theoretical 2D ALE.

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, ew, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, ew, sd)
  x3 <- rnorm(n, x2, x1)
  y <- x1 * x2 * x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

n <- 150
mi <- "0"
ma <- "0p5"
ew <- "5"
va <- "1"
# create example df
cor_df <- get_cor_df(n, 0, 0.5, 5, 1)

# fit splines on df
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 * x2 * x3: #################
prediction_function_123 <- function(x1, x2, x3) {
  return(x1 * x2 * x3)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
  a <- numeric(0)
  for (i in 1:nrow(newdata)){
    a[i]<- prediction_function_123(newdata[i, 1], newdata[i, 2], newdata[i, 3])
  }
  return(a)
})

############# plot 2D ale (x1,x2) theo vs real  #######
ale = FeatureEffect$new(predictor, feature = c('x1','x2'))
ggplotly(plot(ale))

theoretical_ale_x1x2x3 <- function(a, b, mu, si, z01, z02) {
  function(x1, x2) {
    uncentered <- 0.5 * (x2^2 * x1 - (x1 - z01) * (mu^2 + si^2) - ((a + b) / 2) * (x2^2 - z02^2))
    centering <- 0.5 * (z01 * (mu^2 + si^2) + z02^2 * (a + b) / 2 - (mu^2 + si^2) * (a + b) / 2)
    return(uncentered - centering)
  }
}

x1_col <- ale$results$x1
x2_col <- ale$results$x2
theo_results <- numeric(441)
for (i in 1:length(x1_col)) {
  theo_results[i] <- theoretical_ale_x1x2x3(0, 0.5, 5, 1, 0, 2.4)(x1_col[i], x2_col[i])
}

estimated <- plot(ale) + theme_bw()
ale$results$.ale <- theo_results
theo <- plot(ale) + theme_bw()

title_text <- paste("ALE 2D - Theoretic vs. Estimated", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(theo, estimated, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "ALE_2D_theo_vs_estim"
```


```{r theo2Dale, fig.cap='(ref:theo2DaleCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_ALE_2D_theo_vs_estim_x1x2x3_150_0_0p5_5_1.png")
```
(ref:theo2DaleCap) Theoretical 2D ALE (left) and estimated ALE (right).

Figure \@ref(fig:theo2Dale) shows the theoretical ALE compared to the estimated one. In this example it looks pretty similar. The interpretation is a bit hard. Since one can only see the 2nd order effects, corrected for the main effects. It is isolated from the 1st order effect, so it is not possible to state something about the prediction with just this plot. But this problem will be discussed in the coming up chapter.

### 2D ALE vs 2D PDP
In this Chapter only 2D plots for artifcially constructed examples will be analysed. To show the statement, that there are no main effects in the 2D ALE example 2 will be discussed again.

 <!-- TODO: check this example numeration  -->
#### Example 2 - 2D comparison

Just a short reminder of example 2: the prediction function here is $f(x_1, x_2, x_3) = x_1 + x_2 - x_3$ and $x_2$ and $x_3$ are strongly poitive correlated.

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, 2, sd)
  x3 <- rnorm(n, x2, sd)
  y <- x1 + x2 - x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

n <- 150
mi <- "0"
ma <- "2"
va <- "0p5"
# create example df
cor_df <- get_cor_df(n, 0, 2, 0.5)


# fit splines on df
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 + x2 - x3: #################
prediction_function_1plus2minus3 <- function(x1, x2, x3) {
  return(x1 + x2 - x3)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
                            a <- numeric(0)
                            for (i in 1:nrow(newdata)){
                              a[i]<- prediction_function_1plus2minus3(newdata[i, 1], newdata[i, 2], newdata[i, 3])
                            }
                            return(a)
                          })

####################2D plots #######################
ale_2d = FeatureEffect$new(predictor, feature = c('x2','x3'))
ale_2d$results$.ale <- round(ale_2d$results$.ale, 15)
ale <- plot(ale_2d) + theme_bw() + ggtitle("ALE")

pdp_2d = FeatureEffect$new(predictor, feature = c('x2','x3'), method = "pdp")
pdp <- plot(pdp_2d) + theme_bw() + ggtitle("PDP")

meth <- "2d_comp"
form <- "x1_plus_x2_minus_x3"
title_text <- paste("2D PDP vs. ALE", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(pdp, ale, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
```

```{r x1px2mx3ale2D, fig.cap='(ref:x1px2mx3ale2DCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_2d_comp_x1_plus_x2_minus_x3_150_0_2_0p5.png")
```
(ref:x1px2mx3ale2DCap) 2D PDP (left) vs. 2D ALE (right) for prediction function $f(x_1, x_2, x_3) = x_1 + x_2 - x_3$.

Figure \@ref(fig:x1px2mx3ale2D) shows the direct comparison of 2D PDP and 2D ALE. The ALE is almost completely zero as expected. In this additive example there are main effects only and since the 2D ALE is corrected for the main effects of the features, there is no pure 2nd order effect. The PDP in comparison shows the mean prediction. So of course there are the main effects estimated within the 2D PDP as well. Obviously it is hard to compare those two interpretatin algorithms just like this. 

To get a better comparison one can add the main effects (1D ALEs) of the two features of interest to the 2D ALE.

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, 2, sd)
  x3 <- rnorm(n, x2, sd)
  y <- x1 + x2 - x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

n <- 150
mi <- "0"
ma <- "2"
va <- "0p5"
# create example df
cor_df <- get_cor_df(n, 0, 2, 0.5)


# fit splines on df
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 + x2 - x3: #################
prediction_function_1plus2minus3 <- function(x1, x2, x3) {
  return(x1 + x2 - x3)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
                            a <- numeric(0)
                            for (i in 1:nrow(newdata)){
                              a[i]<- prediction_function_1plus2minus3(newdata[i, 1], newdata[i, 2], newdata[i, 3])
                            }
                            return(a)
                          })

################### 1D all linear ###############################################

# plot ale x1 
ale_x1 <- FeatureEffect$new(predictor, feature = 'x1')
p_ale_x1 <- plot(ale_x1) + theme_bw()
# plot pdp on same situation x1
pdp_x1 = FeatureEffect$new(predictor, feature = 'x1', method = 'pdp')
p_pdp_x1 <- plot(pdp_x1) + theme_bw()
#ggplotly(p_ale_x1)
# plot_grid(plot(ale) + theme_bw(), pdp$plot()) + ggtitle("peter")

# plot ale x2
ale_x2 <- FeatureEffect$new(predictor, feature = 'x2')
p_ale_x2 <- plot(ale_x2) + theme_bw()
# plot pdp on same situation x2
pdp_x2 = FeatureEffect$new(predictor, feature = 'x2', method = 'pdp')
p_pdp_x2 <- plot(pdp_x2) + theme_bw()

# plot ale x3
ale_x3 <- FeatureEffect$new(predictor, feature = 'x3')
p_ale_x3 <- plot(ale_x3) + theme_bw()
# plot pdp on same situation x3
pdp_x3 = FeatureEffect$new(predictor, feature = 'x3', method = 'pdp')
p_pdp_x3 <- plot(pdp_x3) + theme_bw()


####################2D plots with added up first order effects #######################
ale_2d = FeatureEffect$new(predictor, feature = c('x2','x3'))
ale_2d$results$.ale <- round(ale_2d$results$.ale, 15)
ale <- plot(ale_2d) + theme_bw() + ggtitle("ALE")

for (i in 1:nrow(ale_2d$results)) {
  ale_2d$results$.ale[i] <- ale_2d$results$.ale[i] + 
    ale_x2$predict(ale_2d$results$x2[i]) +
    ale_x3$predict(ale_2d$results$x3[i])
}
ale_plus <- plot(ale_2d) + theme_bw() + ggtitle("ALE")  
ale_plus_points <- plot(ale_2d) + theme_bw() + geom_point(data = cor_df) + ggtitle("ALE")

meth <- "2d_ale_plus"
form <- "x1_plus_x2_minus_x3"
title_text <- paste("2D ALE added up with 1st order effects", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(ale_plus, ale_plus_points, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
save_text <- paste(paste(meth, form, n, mi, ma, va, sep = "_"), ".png", sep = "")
ggsave(save_text,
       plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
       width = 14, height = 7, units = "cm")

```

```{r ale2DaddedUp, fig.cap='(ref:ale2DaddedUpCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_2d_ale_plus_x1_plus_x2_minus_x3_150_0_2_0p5.png")
```
(ref:ale2DaddedUpCap) 2D ALE added up with 1st order effects of features $x_2$ and $x_3$ for prediction function $f(x_1, x_2, x_3) = x_1 + x_2 - x_3$. In the right plot the underlying 2 dimensional data points are included.

This plot \@ref(fig:ale2DaddedUp) shows the ALE added up with the corresponding 1st order effects of the features. And now it seems pretty much the same as the PDP in figure \@ref(fig:x1px2mx3ale2D). On the right side the same plot can be seen. This one additionally includes the underlying data points regarding features $x_2$ and $x_3$. Furthermore these two features are independent from feature x_1, so the PDP and ALE yield the same correct interpretation that for realistic data points the influence of these two features is close to zero because of their strong positive correlation and their opposing first order effects (figures \@ref(fig:alesx1px2mx3) and \@ref(fig:pdpsx1px2mx3)).

With this is mind, example 1 deserves another look regarding the 2nd order effect in comparison to the PDP.

#### Example 1 - 2D comparison

To be able to compare the 2D ALE from the last chapter for prediction function $f(x_1, x_2, x_3) = x_1 x_2 x_3$ with the 2D PDP one also should add up the 1st order effects to the 2D ALE. 

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, ew, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, ew, sd)
  x3 <- rnorm(n, x2, x1)
  y <- x1 * x2 * x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

cor_df <- get_cor_df(n, 0, 0.5, 5, 1)

# fit splines on df
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 * x2 * x3: #################
prediction_function_123 <- function(x1, x2, x3) {
  return(x1 * x2 * x3)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
  a <- numeric(0)
  for (i in 1:nrow(newdata)){
    a[i]<- prediction_function_123(newdata[i, 1], newdata[i, 2], newdata[i, 3])
  }
  return(a)
})


# plot ale x1 
ale_x1 <- FeatureEffect$new(predictor, feature = 'x1')
p_ale_x1 <- plot(ale_x1) + theme_bw()
# plot pdp on same situation x1
pdp_x1 = FeatureEffect$new(predictor, feature = 'x1', method = 'pdp')
p_pdp_x1 <- plot(pdp_x1) + theme_bw()

# plot_grid(plot(ale) + theme_bw(), pdp$plot()) + ggtitle("peter")

# plot ale x2
ale_x2 <- FeatureEffect$new(predictor, feature = 'x2')
p_ale_x2 <- plot(ale_x2) + theme_bw()
# plot pdp on same situation x2
pdp_x2 = FeatureEffect$new(predictor, feature = 'x2', method = 'pdp')
p_pdp_x2 <- plot(pdp_x2) + theme_bw()

# plot ale x3
ale_x3 <- FeatureEffect$new(predictor, feature = 'x3')
p_ale_x3 <- plot(ale_x3) + theme_bw()
# plot pdp on same situation x3
pdp_x3 = FeatureEffect$new(predictor, feature = 'x3', method = 'pdp')
p_pdp_x3 <- plot(pdp_x3) + theme_bw()

###############################################################

############## adding up 1st order ########
ale_2d = FeatureEffect$new(predictor, feature = c('x1','x2'))
pdp_2d = FeatureEffect$new(predictor, feature = c('x1','x2'), method = "pdp")

for (i in 1:nrow(ale_2d$results)) {
  ale_2d$results$.ale[i] <- ale_2d$results$.ale[i] + 
    ale_x1$predict(ale_2d$results$x1[i]) +
    ale_x2$predict(ale_2d$results$x2[i])
}
ale_plus <- plot(ale_2d) + theme_bw() + ggtitle("ALE + 1st order")

title_text <- paste("2D PDP vs. ALE (1st order effects added up)", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(plot(pdp_2d) + theme_bw() + ggtitle("PDP"), ale_plus, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "comp_2d_1st_orders_added"
save_text <- paste(paste(meth, form, n, mi, ma, ew, va, sep = "_"), ".png", sep = "")
ggsave(save_text,
       plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
       width = 14, height = 7, units = "cm")
```

```{r ale2DaddedUpx1x2x3, fig.cap='(ref:ale2DaddedUpx1x2x3Cap)', echo=FALSE}

knitr::include_graphics("images/ale_1_comp_2d_1st_orders_added_x1x2x3_150_0_0p5_5_1.png")
```
(ref:ale2DaddedUpx1x2x3Cap) 2D PDP vs 2D ALE with added up 1st order effects of features $x_1$ and $x_2$ for prediction function $f(x_1, x_2, x_3) = x_1 x_2 x_3$.

This plot \@ref(fig:ale2DaddedUpx1x2x3) shows exactly what happens in this case, when the 1st order effects of the ALE are added up to the 2nd order effects. One can see that although the connection between $x_2$ and $x_3$ has been detected by the 1st order ALEs (figure \@ref(fig:alesx1x2x3)) and has not been by the 1D PDPs (figure \@ref(fig:pdpsx1x2x3)), the comparable 2D plots look pretty much the same.

In this two examples it seems like the 2D ALE is not that much better than the ALE. But making just a small change to the prediction function for unrealistic values exposes the sensitivity of the PDP for extrapolation.

#### Example 1 modified - 2D comparison

The setting of the problem stays basically the same. Just a small - actually irrelavant - change is made for the prediction function. It is not anymore $f(x_1, x_2, x_3) = x_1 x_2 x_3$ but

$$
f(x_1, x_2, x_3) =  
     \begin{cases}
       x_3^3, \quad\quad\quad\quad\quad~~\text{if}~x_3\ge6 ~~, ~~x_2\le4\\
       x_1 x_2 x_3, \quad\text{else}\\
     \end{cases}
$$
This seems a bit unrealistic but especially tree based predictors tend to do 'strange' things in areas without data. The result of the 2D PDP compared to the ALE (figure \@ref(fig:pdp2Ddamaged)) shows the problem. In the area where $x_2 < 4$ the values of the PDP are huge, since the big values for $x_3^3$ if $x_3 > 6$ increase the average drastically. These values are very unlikely for the underlying distribution but the PDP pretends them to be possible. This is the problem of the extrapolation in the PDP estimation. This is not a problem for the ALE. Here one can not recognise any difference to figure \@ref(fig:ale2DaddedUpx1x2x3), where the prediction function is just $f(x_1, x_2, x_3) = x_1 x_2 x_3$.

```{r eval = FALSE, echo=FALSE}
library(crs)
library(iml)
library(plotly)
library(cowplot)

# create data frame with target variable y = x1 * x2 * x3
# x1 uniformely between min_int and max_int
# x2 normal with E(x2) = ew and sd = sd
# x3 normal with E(x3) = x2 and sd = x1
get_cor_df <- function(n, min_int, max_int, ew, sd) {
  x1 <- runif(n, min_int, max_int)
  x2 <- rnorm(n, ew, sd)
  x3 <- rnorm(n, x2, x1)
  y <- x1 * x2 * x3
  return(as.data.frame(cbind(y, x1, x2, x3)))
}

n <- 150
mi <- "0"
ma <- "0p5"
ew <- "5"
va <- "1"
# create example df
cor_df <- get_cor_df(n, 0, 0.5, 5, 1)

# fit splines on df
model <- crs(y ~ x1, data = cor_df)

############# define function = x1 * x2 * x3: #################
prediction_function_123 <- function(x1, x2, x3) {
  result <- 0
  if (x3 > 6 && x2 < 4) {
    result <- x3^3
  } else {
    result <- x1 * x2 * x3
  }
  return(result)
}

# generate predictor set
X = cor_df[which(names(cor_df) != 'y')]
#predictor = Predictor$new(spl, data = X, y = cor_df$y)
predictor = Predictor$new(model, data = X,
                          y = cor_df$y, predict.fun = function(model, newdata){
                            a <- numeric(0)
                            for (i in 1:nrow(newdata)){
                              a[i]<- prediction_function_123(newdata[i, 1], newdata[i, 2], newdata[i, 3])
                            }
                            return(a)
                          })


# plot ale x1 
ale_x1 <- FeatureEffect$new(predictor, feature = 'x1')
p_ale_x1 <- plot(ale_x1) + theme_bw()
# plot pdp on same situation x1
pdp_x1 = FeatureEffect$new(predictor, feature = 'x1', method = 'pdp')
p_pdp_x1 <- plot(pdp_x1) + theme_bw()

# plot_grid(plot(ale) + theme_bw(), pdp$plot()) + ggtitle("peter")

# plot ale x2
ale_x2 <- FeatureEffect$new(predictor, feature = 'x2')
p_ale_x2 <- plot(ale_x2) + theme_bw()
# plot pdp on same situation x2
pdp_x2 = FeatureEffect$new(predictor, feature = 'x2', method = 'pdp')
p_pdp_x2 <- plot(pdp_x2) + theme_bw()

# plot ale x3
ale_x3 <- FeatureEffect$new(predictor, feature = 'x3')
p_ale_x3 <- plot(ale_x3) + theme_bw()
# plot pdp on same situation x3
pdp_x3 = FeatureEffect$new(predictor, feature = 'x3', method = 'pdp')
p_pdp_x3 <- plot(pdp_x3) + theme_bw()

form <- "x1x2x3"
# make a nice plot:
title_text <- paste("ALEs for each feature", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(p_ale_x1, p_ale_x2, p_ale_x3, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "ALEs"
# save_text <- paste(paste(meth, form, n, mi, ma, ew, va, sep = "_"), ".png", sep = "")
# ggsave(save_text,
#        plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
#        width = 14, height = 7, units = "cm")

title_text <- paste("PDPs for each feature", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(p_pdp_x1, p_pdp_x2, p_pdp_x3, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "PDPs"
# save_text <- paste(paste(meth, form, n, mi, ma, ew, va, sep = "_"), ".png", sep = "")
# ggsave(save_text,
#        plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
#        width = 14, height = 7, units = "cm")

###############################################################

############## adding up 1st order ########
ale_2d = FeatureEffect$new(predictor, feature = c('x1','x2'))
pdp_2d = FeatureEffect$new(predictor, feature = c('x1','x2'), method = "pdp")
#ggplotly(plot(ale_2d))

for (i in 1:nrow(ale_2d$results)) {
  ale_2d$results$.ale[i] <- ale_2d$results$.ale[i] + 
    ale_x1$predict(ale_2d$results$x1[i]) +
    ale_x2$predict(ale_2d$results$x2[i])
}
ale_plus <- plot(ale_2d) + theme_bw() + ggtitle("ALE + 1st order")  
#ggplotly(plot(ale_plus))

title_text <- paste("2D PDP vs. ALE (1st order effects added up)", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(plot(pdp_2d) + theme_bw() + ggtitle("PDP"), ale_plus, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
meth <- "comp_2d_1st_orders_added_and_smaller3_bigger6"
```

```{r pdp2Ddamaged, fig.cap='(ref:pdp2DdamagedCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_comp_2d_1st_orders_added_and_smaller3_bigger6_x1x2x3_150_0_0p5_5_1.png")
```
(ref:pdp2DdamagedCap) 2D PDP vs 2D ALE with added up 1st order effects of features $x_1$ and $x_2$ for stepwise prediction function.


One big advantages of the ALE in general over the PDP is, that it hardly extrapolates in the estimation, which is usually the case for the PDP with correlated features. And one can take a look at seperated 1st and 2nd order effects, which can be very helpful, especially for real blackbox models with complicated links. Furthermore in the next chapter the runtime will turn out to be a strong advocate for the ALE, especially for bigger datasets.

## Runtime comparison 
In this chapter the runtime of ALE and PDP will be compared. Therefore three general sizes of data sets have been sampled. One small with 100, a bigger one with 1,000 and the biggest with 10,000 observations. The number of features vary between 5 and 40, while there are always 2 categorial features and the others are numeric, as is the target variable. The predictor applied to these datasets is a regular SVM. It is way faster than the random forest, where the PDP estimation can easily take half a minute for just 1000 observations.
To compare the runtime, the package 'microbenchmark' has been used. So the discussed results will all have the same structure, which will be explained with the first example.
The comparison will cover the runtime for...

1. ...one numerical feature of interest
2. ...two numerical features of interest
3. ...one categorial feature of interest.

Each of these three will be compared for the different numbers of observations of course but also for different grid sizes (number of intervals the ALE and PDP are estimated on) and varying feature numbers. 

### One numerical feature of interest


```{r eval = FALSE, echo=FALSE}
library(iml)
library(mlr)
library(microbenchmark)
library(e1071)
library(party)

############## sample datasets ##################
get_numeric_sampling <- function(nrows, ncols) {
  y_regr <- c(1:ncols)
  for (i in 1:(ncols-2)) {
    mu <- runif(1, 0, 100)
    si <- runif(1, 5, 10)
    y_regr <- cbind(y_regr, rnorm(nrows, mu, si))
  }
  y_regr <- as.data.frame(y_regr)
  multi_fact <- as.factor(c(1:10))
  p <- runif(1, 0, 1)
  V_bin <- as.factor(rbinom(nrows, 1, p))
  y_regr <- cbind(y_regr, multi_fact, V_bin)
  return(y_regr)
}

regr_100_5    <- get_numeric_sampling(100, 5)
regr_100_20   <- get_numeric_sampling(100, 20)
regr_100_40   <- get_numeric_sampling(100, 40)
regr_1000_5   <- get_numeric_sampling(1000, 5)
regr_10000_5  <- get_numeric_sampling(10000, 5)

t.regr_100_5    <- makeRegrTask(data = regr_100_5, target = "y_regr")
t.regr_100_20   <- makeRegrTask(data = regr_100_20, target = "y_regr")
t.regr_100_40   <- makeRegrTask(data = regr_100_40, target = "y_regr")
t.regr_1000_5   <- makeRegrTask(data = regr_1000_5, target = "y_regr")
t.regr_10000_5  <- makeRegrTask(data = regr_10000_5, target = "y_regr")
###########################################

############### fit svm ###################
l.svm <- makeLearner("regr.svm")
fit.svm.regr_100_5    <- train(l.svm, t.regr_100_5)
fit.svm.regr_100_20   <- train(l.svm, t.regr_100_20)
fit.svm.regr_100_40   <- train(l.svm, t.regr_100_40)
fit.svm.regr_1000_5   <- train(l.svm, t.regr_1000_5)
fit.svm.regr_10000_5  <- train(l.svm, t.regr_10000_5)

svm.regr_100_5    <- Predictor$new(fit.svm.regr_100_5, data = regr_100_5, y = regr_100_5$y_regr)
svm.regr_100_20   <- Predictor$new(fit.svm.regr_100_20, data = regr_100_20, y = regr_100_20$y_regr)
svm.regr_100_40   <- Predictor$new(fit.svm.regr_100_40, data = regr_100_40, y = regr_100_40$y_regr)
svm.regr_1000_5   <- Predictor$new(fit.svm.regr_1000_5, data = regr_1000_5, y = regr_1000_5$y_regr)
svm.regr_10000_5  <- Predictor$new(fit.svm.regr_10000_5, data = regr_10000_5, y = regr_10000_5$y_regr)
########################################

############### define functions tfor microbenchmark #################
#one numeric
ale_one_numeric <- function(predi, feature = "V2", grid.size) {
  return(FeatureEffect$new(predi, feature = feature, grid.size = grid.size))
}

pdp_one_numeric <- function(predi, feature = "V2", grid.size) {
  return(FeatureEffect$new(predi, feature = feature, grid.size = grid.size, method = "pdp"))
}

# two numeric
ale_two_numeric <- function(predi, feature = c("V2","V3"), grid.size) {
  return(FeatureEffect$new(predi, feature = feature, grid.size = grid.size))
}

pdp_two_numeric <- function(predi, feature = c("V2","V3"), grid.size) {
  return(FeatureEffect$new(predi, feature = feature, grid.size = grid.size, method = "pdp"))
}

# one categorial
ale_one_cat <- function(predi, feature = "multi_fact") {
  return(FeatureEffect$new(predi, feature = feature))
}

pdp_one_cat <- function(predi, feature = "multi_fact") {
  return(FeatureEffect$new(predi, feature = feature, method = "pdp"))
}
####################################################################

############################## one numeric feature ##########
# pdp vs ale increasing columns and grid size
microbenchmark(ale_one_numeric(svm.regr_100_5,  grid.size = 20),
               ale_one_numeric(svm.regr_100_5, grid.size = 100),
               ale_one_numeric(svm.regr_100_20, grid.size = 20),
               ale_one_numeric(svm.regr_100_40, grid.size = 20),
               pdp_one_numeric(svm.regr_100_5,  grid.size = 20),
               pdp_one_numeric(svm.regr_100_5, grid.size = 100),
               pdp_one_numeric(svm.regr_100_20, grid.size = 20),
               pdp_one_numeric(svm.regr_100_40, grid.size = 20),
               times = 10)

# pdp vs ale increasing rows
# pdp_one_numeric(svm.regr_1000_5, grid.size = 20)
# microbenchmark(pdp_one_numeric(svm.regr_100_5,  grid.size = 20),
#                pdp_one_numeric(svm.regr_1000_5, grid.size = 20),
#                times = 10)
# ale_one_numeric(svm.regr_10000_5, grid.size = 20)

microbenchmark(ale_one_numeric(svm.regr_100_5,   grid.size = 20),
               ale_one_numeric(svm.regr_1000_5,  grid.size = 20),
               ale_one_numeric(svm.regr_10000_5, grid.size = 20),
               pdp_one_numeric(svm.regr_100_5,   grid.size = 20),
               pdp_one_numeric(svm.regr_1000_5,  grid.size = 20),
               pdp_one_numeric(svm.regr_10000_5, grid.size = 20),
               times = 5)
##########################################################################

############################## two numeric features ##########
# pdp vs ale increasing columns and grid size
microbenchmark(ale_two_numeric(svm.regr_100_5,  grid.size = 20),
               ale_two_numeric(svm.regr_100_5, grid.size = 100),
               ale_two_numeric(svm.regr_100_20, grid.size = 20),
               ale_two_numeric(svm.regr_100_40, grid.size = 20),
               pdp_two_numeric(svm.regr_100_5,  grid.size = 20),
               pdp_two_numeric(svm.regr_100_5, grid.size = 100),
               pdp_two_numeric(svm.regr_100_20, grid.size = 20),
               pdp_two_numeric(svm.regr_100_40, grid.size = 20),
               times = 10)

# pdp vs ale increasing rows
microbenchmark(ale_two_numeric(svm.regr_100_5,   grid.size = 20),
               ale_two_numeric(svm.regr_1000_5,  grid.size = 20),
               ale_two_numeric(svm.regr_10000_5, grid.size = 20),
               pdp_two_numeric(svm.regr_100_5,   grid.size = 20),
               pdp_two_numeric(svm.regr_1000_5,  grid.size = 20),
               pdp_two_numeric(svm.regr_10000_5, grid.size = 20),
               times = 1)
##########################################################################

############################## one categorial feature ##########
# pdp vs ale increasing columns and grid size
microbenchmark(ale_one_cat(svm.regr_100_5),
               ale_one_cat(svm.regr_100_20),
               ale_one_cat(svm.regr_100_40),
               pdp_one_cat(svm.regr_100_5),
               pdp_one_cat(svm.regr_100_20),
               pdp_one_cat(svm.regr_100_40),
               times = 10)

# pdp vs ale increasing rows
microbenchmark(ale_one_cat(svm.regr_100_5),
               ale_one_cat(svm.regr_1000_5),
               ale_one_cat(svm.regr_10000_5),
               pdp_one_cat(svm.regr_100_5),
               pdp_one_cat(svm.regr_1000_5),
               pdp_one_cat(svm.regr_10000_5),
               times = 10)
##########################################################################

```

```{r runtime1DnumColAndSize, fig.cap='(ref:runtime1DnumericColAndSizeCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_one_numeric_cols_and_gridsize.PNG")
```
(ref:runtime1DnumColAndSizeCap) Runtime comparison ALE vs. PDP for one numeric feature. Differences for number of features and grid size.

Figure \@ref(fig:runtime1DnumColAndSize) shows the runtimes for different configurations in milliseconds. The microbenchmark output shows the compared expressions (here the calculation of ALE and PDP) in the first collumn. The other columns are the measured runtime for 10 different runs. From left to right it is the minimum runtime, the lower quantile of the runtimes, the mean, the median, the upper quantile and the maximal runtime. The main attention usually lies on the mean. In the expression there are also configurations for the sampled dataset integrated. For example 'ale_one_numeric(svm.regr_100_5, grid.size = 20)' represents the following estimation: An ALE for one numeric feature of interest has been estimated. The prediction funciton was a SVM fitted and evaluated on a sample of 100 observations with 5 features. The grid size in this case was 20, so evaluated on 20 intervals.
This plot \@ref(fig:runtime1DnumColAndSize) shows the comparison for a change in grid size and number of features for one numeric feature of interest. It seems like the number of features does barely have an influence on the runtime. Additionally for the ALE the grid size is not signifcantly changing the runtime. That is comletely different for the PDP. Here a factor 5 for number of intervals increases the runtime by the same factor. This can be derived from the estimation. The ALE does the same number of predictions for any number of intervals, namely #observaions $\times$ 2. It just averages more often for mor intervals. But that happens without the prediction function and is just a simple mean calculation, so it barely needs time. The PDP on the other hand estimates the mean prediction for each interval border. So here (#intervals + 1) $\times$ #observations predictions have to be calculated. So the runtime grows linearly with the grid size and factor #observations. This is also the explanation for the next comparison (figure \@ref(fig:runtime1DnumNrow)). Here again one can see a way faster increas of runtime for PDPs than for ALEs when increasing the number of observations

```{r runtime1DnumNrow, fig.cap='(ref:runtime1DnumNrowCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_one_numeric_nrows.PNG")
```
(ref:runtime1DnumNrowCap) Runtime comparison ALE vs. PDP for one numeric feature. Differences for number of observations.

### Two numerical features of interest

```{r runtime2DnumColAndSize, fig.cap='(ref:runtime2DnumericColAndSizeCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_two_numeric_cols_and_gridsize.PNG")
```
(ref:runtime2DnumColAndSizeCap) Runtime comparison ALE vs. PDP for two numeric features. Differences for number of features and grid size.

In figure \@ref(fig:runtime2DnumColAndSize) the runtimes for different 2D ALE and PDP configurations can be seen. Again the number of features is not a great deal for both algorithms. The ALE has no huge increase in runtime when the grid size is higher but the PDP has. The issue here is that the estimation for 2D PDP requires $gris.size^2 \times \#observations$ predictions while the ALE just needs $4 \times \#observations$ predictions calculated for the estimation. This especially can be seen when increasing the number of observations. 

```{r runtime2DnumNrow, fig.cap='(ref:runtime2DnumNrowCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_two_numeric_nrows.PNG")
```
(ref:runtime2DnumNrowCap) Runtime comparison ALE vs. PDP for two numeric features. Differences for number of observations.

Figure \@ref(fig:runtime2DnumNrow) shows such an increas in observations. One can see that factor 100 in observations becomes almost factor 1,000 for the runtime of PDP while it is just a bit more than 10 for ALE. 

### One categorial feature of interest

Lastly a look at the estimation for 1D categorial PDP and ALE will be taken. 

```{r runtime1DcatColAndSize, fig.cap='(ref:runtime1DcatColAndSizeCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_one_cat_cols_and_gridsize.PNG")
```
(ref:runtime1DcatColAndSizeCap) Runtime comparison ALE vs. PDP for one categorial feature. Differences for number of features only.

Figure \@ref(fig:runtime1DcatColAndSize) shows the runtimes of PDP and ALE for a categorial feature of interest. Analyzing categorial features does not require a grid size, since the number of categories already defines the number of different evaluations. This time one recognises that it is the other way around. The calculation time stays the same for the PDP with growing number of features, while ALE shows a significant growth. This is clearly caused by the reordering of the features for their category (will be explained in the next chapter). The reordering is based on kind of nearest neighbors (depends on implementation). The calculation of these neighbors takes longer the more features have to be taken into account. 

```{r runtime1DcatNrow, fig.cap='(ref:runtime1DcatNrowCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_one_cat_nrows.PNG")
```
(ref:runtime1DcatNrowCap) Runtime comparison ALE vs. PDP for one categorial feature. Differences for number of observations. 

Here (figure \@ref(fig:runtime1DcatNrow)) a similar picture as in figure \@ref(fig:runtime1DnumColAndSize) can be seen. Just this time compared to the estimation for one numeric feature the ALE is way slower for the categorial feature, while the PDP is twice as fast as for the numeric feature. That might come from the fact that the grid size here (\@ref(fig:runtime1DnumColAndSize)) was 20 and in this case there are just 10 classes for the feature of interest. Meaning that half as many calculations for the estimation are required. So it might be the same speed for the PDP from numeric to categorial (at least with comparable parameters). The ALE will always be slower for categorial features, since the reordering of the categories is necessary. 

In general one can state that ALE is by far faster. For a SVM that might not be that much of a problem. But with ensamble predictors like a random forest it can be very slow to calculate a PDP for a high grid size and 10,000+ observations. 

## Comparison for unevenly distributed data - Example 4: Munich rents

To conclude this chapter a real world problem with a fitted learner will be analyzed with ICE, PDP and ALE, to see them in action.
This is an example with data for rents in Munich from 2003. The target variable 'nm' is the rent per month per flat. To predict the rent a random forest has been fitted. The features in this example are 'wfl' (size in square meters) and 'rooms' (number of rooms) of the flat. These two variables are clearly positively correlated, since there will not be an (TODO: tt ?) appartment with 15 squaremeters and 5 rooms. The other features are not that strongly correlated as one can see in figure \@ref(fig:correlationMatrixRents). For the fit only 'wfl' and 'rooms' were used to fit the random forest.

```{r eval = FALSE, echo=FALSE}
library(ggcorrplot)
library(randomForest)
library(iml)
library(cowplot)
library(dplyr)
library(plotly)

#import data
dataTrain <- read.csv( file="munich_rents_03.csv", 
                      header = TRUE , sep = "," , stringsAsFactors = FALSE)




dataTrain <- select(dataTrain, nm, wfl, rooms, bj, bez)
# analyze for correlation
cor(dataTrain)
ggplotly(ggcorrplot(cor(dataTrain)))

dataTrain$rooms <- as.factor(dataTrain$rooms)
# corr wfl to rooms: 0.84

# train rf
rf.rents <- randomForest(`nm` ~ wfl + rooms, data = dataTrain) # , importance = T)
rf.rents <- svm(`nm` ~ wfl + rooms, data = dataTrain) #
rf.pred <- predict(rf.rents, data = dataTrain)
dataWithPred <- as.data.frame(cbind(rf.pred, dataTrain))


# analyze fitted predictor
mod = Predictor$new(rf.rents, data = dataTrain) #, type = "prob", class = 2)
ale = FeatureEffect$new(mod, feature = "wfl", grid.size = 15)
# plot(ale)
ale <- plot(ale) + theme_bw()
pdp = FeatureEffect$new(mod, feature = "wfl", method = "pdp")
# plot(pdp)
pdp <- plot(pdp)+ theme_bw()
ice = FeatureEffect$new(mod, feature = "wfl", method = "ice")
ggplotly(plot(ice))
# plot(ice)
ice <- plot(ice) + theme_bw()

# rbind(dataTrain[1993,],
#       dataTrain[1839,],
#       dataTrain[2049,],
#       dataTrain[2052,],
#       dataTrain[2053,],
#       dataTrain[2048,])
# 
# ale$results

#           nm nmqm wfl rooms   bj bez
# 1993 1159.36 7.63 152     5 2000  19
# 1839  779.37 7.22 108     6 1948  20
# 2049  802.99 8.54  94     4 1992  19
# 2052  323.42 9.24  35     1 1970  21
# 2053  506.19 7.79  65     3 1966   7
# 2048  260.15 5.00  52     2 1948  16

# compare plots:
form <- "rf_rent_for_rooms_and_wfl_ALE_vs_ICE"
title_text <- paste("PDP, ICE and ALE for rents in Munich", sep="")
title <- ggdraw() + draw_label(title_text, fontface='bold')
plot_row <- plot_grid(ice, ale, pdp, nrow = 1)
# rel_heights values control title margins
plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1))
save_text <- paste(paste(form, sep = "_"), ".png", sep = "")
ggsave(save_text,
       plot = plot_grid(title, plot_row, ncol=1, rel_heights=c(0.1, 1)),
       width = 18, height = 7, units = "cm")

```

```{r correlationMatrixRents, fig.cap='(ref:correlationMatrixRentsCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_correlation_munich_rents.png")
```
(ref:correlationMatrixRentsCap) Correlatin matrix for rents in Munich.

```{r pdpaleRents, fig.cap='(ref:pdpaleRentsCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_rf_rent_for_rooms_and_wfl.png")
```
(ref:pdpaleRentsCap) PDP and ALE plots for influence of space on rents in Munich.

Figure \@ref(fig:pdpaleRents) shows a more or less expected influence of space on the rent. The bigger the apartment the more expensive it is. In the area with a lot of data between 0 and 100 the PDP looks more smooth than the ALE which is a bit shaky. In the area with not that much observations it is the other way around. The PDP suddenly breaks down what seems quite unrealistic, while the ALE has a pretty straight trend. Since the ALE shows a more expected behavior for the prediction of rents one could tend to state that the ALE outperforms the PDP. One could think that some unrealistic feature combinations in the estimation of the PDP caused this strange drop. But a look at the ICE plot reveals something else.

```{r aleIceRents, fig.cap='(ref:aleIceRentsCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_rf_rent_for_rooms_and_wfl_ALE_vs_ICE.png")
```
(ref:aleIceRentsCap) ICE, ALE and PDP plots for influence of space on rents in Munich.

Figure \@ref(fig:aleIceRents) additionally shows the ICE curves for this example. Since the only other feature used for the fit was 'rooms' and in the data set are just flats with 6 or less rooms, there are just 6 graphs. Now one could argue, maybe the appartments with less than 4 rooms (which are way more in this data set than those with 4 or more rooms) somehow cause the strange drop for the PDP. But figure (ref:iceZoomedRents) shows that almost all rooms have this drop, especially the apartments with 4 and 5 rooms. 

```{r iceZoomedRents, fig.cap='(ref:iceZoomedRentsCap)', echo=FALSE}

knitr::include_graphics("images/ale_1_ice_zoomed.PNG")
```
(ref:iceZoomedRentsCap) ICE for rents in Munich, zoomed in for the critical area.

The issue here is that rooms dont have a strong influence on the prediction at all. In return the PDP does not get problems with the correlation of the two features. And the PDP in the iml implementation generates a equidistant grid on the area with observations for feature 'wfl'. On the other hand the ALE divides this area aiming for equally many observations in each interval. This results in very small intervalls for apartments with less than 109 squaremeters space. But the flats with 109 or more squaremeters are evaluated in one interval. This simply yields to this ALE plot, where it just ignores/skips this drop. And as one can see this can be dangerous when interpreting the prediction function. In this special situtation the ALE might get better the true link between the rent and the size of the apartments but that is not what one is interested in. The goal is always to interpret the predictor and not the data. 

This example demonstrated a crucual weakness of the ALE regarding the size of the intervals, which will be discussed in the next chapter. It also shows that ICE and PDP might still be worth a look despite their issues with correlated features and runtime. In general, if one needs to get a deep understanding of the prediction function it might be clever to use as many interpretation algorithms as possible. By being aware of their strengths and weeknesses and combining the results of those algorithms one can get a detailed look at the influence of each variable which should also be reliable.



## For the Appindex - Calculation theoretic 2D ALE

Features $x_1$, $x_2$, $x_3$ and the prediction function $\hat{f}(x_1, x_2, x_3) = x_1 x_2 x_3$ are given.
The features are sampled from the these disrtibutions:
$X_1 \sim \mathcal{U}(a,~b)$, $X_2 \sim \mathcal{N}(\mu,~\sigma)$ and $X_3\mid X_2, X_1 \sim \mathcal{N}(X_2,X_1)$
The theoretical 2D ALE for features $x_1$ and $x_2$ will be calculated.

1. Calculation of uncorrected and uncentered 2nd order effect:
\begin{align} 
\widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(x_1, x_2) 
&= \int_{z_{0,~1}}^{x_1}  \int_{z_{0,~2}}^{x_2} E[\hat{f}^{(1,~2)}(X_1,~X_2,~X_3)\mid X_1 = z_1,~X_2 = z_2]~dz_2~dz_1 \notag \\
&= \int_{z_{0,~1}}^{x_1}  \int_{z_{0,~2}}^{x_2} E[X_3 \mid X_1 = z_1,~X_2 = z_2]~dz_2~dz_1 \notag \\
&= \int_{z_{0,~1}}^{x_1}  \int_{z_{0,~2}}^{x_2} z_2 ~dz_2~dz_1 \notag \\
&= \int_{z_{0,~1}}^{x_1}  \frac{1}{2} (x_2^2 - z_{0,~2}) ~dz_1 \notag \\
&= \frac{1}{2} (x_2^2 - z_{0,~2})~(x_1 - z_{0,~1}) 
\end{align}

2. Calculation of corrected pure 2nd order effect:

\begin{align}
\begin{split}
\widetilde{ALE}_{\hat{f},~1,~2}(x_1, x_2) = 
&\widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(x_1, x_2) ~ -  \int_{z_{0,~1}}^{x_1}  E[\frac{\delta\widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(X_1, X_2)}{\delta X_1}\mid X_1 = z_1]~dz_1 \notag \\
&- \int_{z_{0,~2}}^{x_2}  E[\frac{\delta\widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(X_1, X_2)}{\delta X_2}\mid X_2 = z_2]~dz_2
\end{split}
(\#eq:ale2DExampleCorrection)
\end{align}


The two terms which are correcting for the main effect of the two features will be calculated seperately.

\begin{align} 
\begin{split}
\int_{z_{0,~1}}^{x_1}  E[\frac{\delta\widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(X_1, X_2)}{\delta X_1}\mid X_1 = z_1]~dz_1 
&= \int_{z_{0,~1}}^{x_1}  E[\frac{1}{2}(X_2^2 - z_{0, ~2}^2)\mid X_1 = z_1]~dz_1 \notag \\
&= \int_{z_{0,~1}}^{x_1}  \frac{1}{2}(\mu^2 + \sigma^2 - z_{0,~2}^2) ~dz_1 \notag \\
&= \frac{1}{2}(\mu^2 + \sigma^2 - z_{0,~2}^2)~(x_1 - z_{0,~1})
\end{split}
  (\#eq:ale2DExampleCorrection1)
\end{align}

\begin{align} 
\begin{split}
\int_{z_{0,~2}}^{x_2}  E[\frac{\delta\widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(X_1, X_2)}{\delta X_2}\mid X_2 = z_2]~dz_2
&= \int_{z_{0,~2}}^{x_2}  E[X_2 (X_1 - z_{0, ~1})\mid X_2 = z_2]~dz_2 \notag \\
&= \int_{z_{0,~2}}^{x_2}  z_2(\frac{a+b}{2} - z_{0, ~1}) ~dz_2 \notag \\
&= \frac{1}{2}(\frac{a+b}{2} - z_{0, ~1})(x_2^2 - z_{0, ~2}^2) 
\end{split}
  (\#eq:ale2DExampleCorrection2)
\end{align}

Combining \@ref(eq:ale2DExampleCorrection1) and \@ref(eq:ale2DExampleCorrection2) with \@ref(eq:ale2DExampleCorrection) yields:

\begin{align} 
\widetilde{ALE}_{\hat{f},~1,~2}(x_1, x_2) &= \widetilde{\widetilde{ALE}}_{\hat{f},~1,~2}(x_1, x_2) -~ \frac{1}{2}(\mu^2 + \sigma^2 - z_{0,~2}^2)~(x_1 - z_{0,~1}) -~ \frac{1}{2}(\frac{a+b}{2} - z_{0, ~1})(x_2^2 - z_{0, ~2}^2) \notag \\
&= x_2^2~x_1 + (x_1 - z_{0,1})(\mu^2+\sigma^2) - \frac{a + b}{2}(x_2^2-z_{0,~2}^2)
\end{align}

The last part is the centering for the mean:

\begin{align} 
ALE_{\hat{f},~1,~2}(x_1, x_2) &= \widetilde{ALE}_{\hat{f},~1,~2}(x_1, x_2) ~ -  E[\widetilde{ALE}_{\hat{f},~1,~2}(X_1, X_2)] \notag \\
&= \frac{1}{2} (x_2^2~x_1 + (x_1 - z_{0,1})(\mu^2+\sigma^2) - \frac{a + b}{2}(x_2^2-z_{0,~2}^2) \notag \\
& ~~~~~ - E[X_2^2~x_1 + (X_1 - z_{0,1})(\mu^2+\sigma^2) - \frac{a + b}{2}(X_2^2-z_{0,~2}^2)] ) \notag \\
&= \frac{1}{2} [x_2^2~x_1 - (x_1 - z_{0,1})(\mu^2+\sigma^2) - \frac{a + b}{2}(x_2^2-z_{0,~2}^2) \notag \\
& ~~~~~ - (z_{0,1}(\mu^2+\sigma^2) + z_{0,~2}^2 \frac{a + b}{2} - (\mu^2+\sigma^2) \frac{a + b}{2}) ] \notag \\
&= \frac{1}{2} [x_2^2~x_1 - x_1(\mu^2+\sigma^2) - x_2^2 \frac{a + b}{2} + (\mu^2+\sigma^2) \frac{a + b}{2} ]
\end{align}

This formula was used to calculate the theoretical plot in figure \@ref(fig:theo2Dale).






